# 그리디 (탐욕법)

- 현재 상황에서 지금 당장 좋은 것을 고르는 방법
- 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
- 최적의 해를 찾지 못할 수 있음
- 즉, 탐욕적으로 답을 찾는게 정당한 방법인지 (자연스럽게 최적해에 근접하게되는지) 검토해야함

<br/>

## 예제

### 예제 3-1

- 동전으로 거스름돈을 줄 때 최소개만 주기
- 동전종류: 500, 100, 50, 10
- 입력: 거슬러줘야 할 돈 N
- 제한사항: 입력은 항상 10의 배수이다.

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin  # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    n %= coin

print(count)
```

<br/>

### 실전문제 3-2

- 큰 수의 법칙
- 주어진 배열에 수를 M번 선택해서 만들 수 있는 가장 큰수를 구하라
- 예외사항: 단, 각 원소를 K+1번 연속으로 선택할 수 없다.
- 입력: 다양한 수로 이루어진 배열이 주어진다.
    - 첫째 줄에 N(2<=N<=1000), M(1<=M<=10000), K(1<=K<=10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
    - 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10000 이하의 수로 주어진다.
    - 입력으로 주어지는 K는 항상 M보다 작거나 같다.

- 예시입출력

```python
5
8
3
2
4
5
4
6

46
```

```python
# N, M, K를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort()  # 입력받은 수들 정렬하기
first = data[n - 1]
second = data[n - 2]

result = 0

while True:
    for i in range(k):  # 가장 큰 수를 K번 더하기
        if m == 0:  # m이 0이라면 반복문 탈출
            break
        result += first
        m -= 1  # 더할 때마다 1씩 빼기
    if m == 0:
        break
    result += second  # 두번째로 큰 수를 한번 더하기
    m -= 1

print(result)
```

<br/>

### 실전문제 3-3 (숫자카드게임)

- N개의 행에 각각 M개의 카드가 있다.
- 입력
    - 첫째 줄에 숫자 카드들이 놓인 행열의 개수 N, M이 주어진다. (1<=N,M<=100)
    - 둘째 줄 부터 N개의 줄에 걸처 각 카드에 적힌 숫자가 주어진다.
    - 각 숫자는 1 이상 10,000 이하의 자연수
- 출력
    - 선택한 카드에 적힌 숫자를 출력한다.

```python
n, m = map(int, input().split())

result = 0
for i in range(n):
    data = list(map(int, input().split()))  # 한줄씩 입력받으면서
    min_value = min(data)  # 각 행에 있는 가장 작은 숫자를 뽑는다.
    result = max(result, min_value)  # 매행에서 뽑은 숫자 중 가장 큰 수를 기억한다.

print(result)
```

<br/>

### 실전문제 3-4 (1이 될 때까지)

- 어떤 수 N을 1로 만들려한다. 가능한 연산은 아래 두가지 뿐이다.
    - N에서 1을 뺀다.
    - N을 K로 나눈다.
- 입력
    - 첫째 줄에 N(2<=N<=100,000)과 K(2<=K<=100,000)이 공백으로 구분된다.
    - N은 항상 K보다 크거나 같다.
- 출력
    - N이 1이 될때까지 총 몇번에 연산을 해야되는지 최소값을 출력한다.
- N을 K로 최대한 많이 나눠야하는게 최소값이 된다.

```python
n, k = map(int, input().split())
result = 0

while True:
    # K로 나누어 떨어질 때 까지 1씩 빼기
    target = (n // k) * k
    result += (n - target)
    n = target

    # N을 K로 나눌 수 없다면 반복문 탈출
    if n < k:
        break

    # K로 나누기
    result += 1
    n //= k

# 남은 수만큼 1씩 빼기 진행
result += (n - 1)
print(result)
```
